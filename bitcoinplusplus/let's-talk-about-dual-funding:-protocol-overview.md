---
title: "Let's Talk About Dual Funding: Protocol Overview"
transcript_by: saltykate via review.btctranscripts.com
media: https://www.youtube.com/watch?v=OFMU1xV5uQk
tags: ["lightning","dual funding","Dual Funded Channels","Multisig"]
speakers: ["Lisa Neigut"]
categories: ["conference"]
date: 2023-03-16
---


# Dual Funding Protocol Overview

## Unspent Transactions Output
Unspent transaction object, right? That is locked up. This is like locked up. So another way of saying this is like Bitcoin that's unspent, right? Object? What did you say? Shut up. I didn't check. I thought it was a normal code. Object-oriented programming Never made it to Bitcoin? No? OK. All right. Bitcoin is unspent, but it requires two parties to sign, right? So how do we do that? How do we say, OK, this is Bitcoin. It can be spent, but in order to spend it, you need two people to sign off on it. How do we make that happen? Multisig. Multisig. Multisig. And that's the multisig that two people sign off, so it's two of two multisig. Great, okay. 

## Lightning channels and multisig, Bitcoin script and the lightning protocol
So lightning channel, we're talking about lightning channels. A lightning channel is a, really, it's a UTXO that is locked up with a two of two. Can you guys read that? That's okay. Great, okay, good. Great, perfect. Wow, that's good. That's good. OK. All right, great. All right, so lightning channel. All right, so the question is then, so OK, then the process of opening a lightning channel, of opening a lightning channel, how do we make that work? So what does that involve? We want to open a channel. That means where two people, like lightning nodes, whatever, are going to make a two of two output right somehow right so what does that mean What does it take to make a 2 of 2 output? Does anyone know what the script is for a 2 of 2 op check thing? No? Anyone want to help me out here? Who has? Does anyone recognize this? What is this? Does anyone know what this is? Who's in my class? Where's Liron? Liron, what is this? This is a script. It's a script. It's a Bitcoin script. It's a Bitcoin script, right? 

What does a Bitcoin script do? It helps you lock up Bitcoins. It locks Bitcoins up, right? So we didn't cover this in class. We didn't have time this week. Liron was in my class earlier this week, my base 58 transactions class. We talked about scripts. So this is how you write contracts or like how you write programs in Bitcoin is you write Bitcoin scripts right. So this is the script definition for opening a Lightning channel right. So The reason we're going through this is so we know what we need to open a channel, right? We need some information. Two parties are going to come together. 

So, lightning is a protocol, right? What is protocol design? Protocol is figuring out what two people need to communicate to accomplish a task, right? Together, to some extent. And most protocols are like two people talking. You can get multi-party ones if they're complicated. Lightning is all written, you have two people having a conversation. So we need to figure out what they need to tell each other so that we can make it UTXO on chain. Like our task that we want to do is we want to make it to a multi-sig, right? And we want to end up with one of these at the end of this process. We're going to have a conversation. And we need to know what we need to talk about in our conversation to make this happen, right? Everyone following? Okay, great. So, in order to know what we should talk about, well, we need to know what we're putting information into, right? So this is the, this is the script that we're going to put on chain. 

##Open lightning channel between two node and checking multisig with pubkeys 
And notice there's two things we're missing. 

    OP_2 <pubkey1> <pubkey2> OP_2 OP_CHECKMULTISIG
We're missing a pubkey1 and a pubkey2. Right? Does everyone know what this means? Okay, so the op2, so is everyone familiar with how op check multisig works? Ah, okay. I'm going to put my little hand over there. Okay. Okay, so should we watch a check multisig? How long do we have? Is this going to be a way off topic? We're not going to do it. It's fine. You guys will have to come to the base 58 class or something and walk through it. Okay, but the whole point is that in order to make this script, there's two items, two pieces of information we need, we need one pubkey and we need two pubkeys. 
## checking that signatures match
So the general idea behind a check multiseg is that when you have a check multiseg, you're going to need a signature that matches each of the pubkeys, right? And there's two pubkeys in here. There's pubkey one and pubkey two, one from each participant. So they're going to give you a pubkey, you're going to put it into this contract, then you lock the money up on chain, and it can't move anywhere unless both of these pubkeys sign off on any new thing. Okay, this is sort of like a side distraction, but it's kind of interesting. So what we need is we need, if we're building this, we need to get a pubkey for the party. Right? Cool. So there's another thing, right? So everyone knows that we have a transaction, right?

You have a list of inputs, and then you have a list of outputs. And one of these list of outputs needs to be a 2 of 2 multisig. Anyone? I feel like I'm making these people. So in a transaction, you have inputs, you have outputs, and one of them needs to be this two of two multisig, right? So in the old days, old days,

   
 V1, so anyone who's using V1 channel opens on lightning. The way that this works is that someone says, so you have two nodes. You have node one, and then on the other side of the channel, you have node two, right? And they're talking to each other. So node one is going to send a message all the way over to node two, right? So the first Node is going to say, hey, I want to open a channel. And part of that is going to be that I have a pubkey here, pubkey one, right? And it's going to send that over to node two, right? And then node two is going to get that message. And what is node two going to say in response? They're going to, oh, it's a lot harder to do the other direction. No, no, no. OK. Node two is going to send a message back, right? They're going to send a message back, and They're going to say no way, Jose, goodbye, and hang up on you. And that's the end of the conversation, right? That's their right, they can do that. They can just end the conversation. They don't have to talk to you if they don't want to. But let's say that they're like, okay, sure, you can open a channel to me, right? So they're gonna say, okay, fine. Here's Pubkey too, right? So that's how we send each other pubkeys back and forth. You might be like, Lisa, what? Surely this is not what specs look like, right? Surely a spec looks a little different, right? Okay, but I have some news. It's like, no, it doesn't look much different at all, let's go find it. I have it up here. Oh, okay, so everyone, this is probably hard to read, let's make it a little bigger. That's not useful for anyone. Okay, okay, actually that's not bad, that's not bad. Alright, So what is the specification? It's just literally writing out this stuff like this, except in a little fancier terminology. But essentially, this is all that we write down with specs. 

So let's go look at these really fast. So we'll make this a little more concrete than me just like having a conversation with myself on the internet. Where's the code? New code. Oh, so fun fact, this is in, so these are the specs.



## [Lightning Network In-Progress Specifications](https://github.com/lightning/bolts) 

The Lightning has a written out paper where they write down where the specs are. This is like, I'm not managing this like this. OK, so what we're talking about is channel establishment, right? [Channel Establishment](https://github.com/lightning/bolts/blob/master/02-peer-protocol.md#channel-establishment)Building, opening a channel. This open channel message is this one here. Hey, I want to open a channel is also the formal, the official name is Open Channel. 

     open_channel

And then the formal name for this response is Accept Channel, right? Open Channel, Accept Channel.

     accept_channel

 So here they are. We can go look at them, what's inside the message they're actually sending. There's a lot more info in here than just the pub key. There's a few more things in here. So funding Satoshi is how much money you want to put in a channel. Push inside is how much money I'm just giving you because I decided I want you to have it. It's a bribe, sort of. There's some other stuff in here to set this up. Fee rate is the... I don't know. I'm going to hand wave over that. Here's the funding pub key. So this is going to be basically inside here, there's an object called, there's a piece of info called funding pubkey, which I've been calling pubkey1. OK, cool. So there's a message. So everyone can see how we write out what the message is. And you just send it over the wire to your buddy node 2, and node 2's gonna get it and be like, all right, now node 2's gonna have all this information. Okay, so then node 2's like, all right, cool, that's nice, dude. And we have descriptions of each of these things. Here, funding pubkey is the pubkey, and then two of two multisig scripts are the funding transaction output, right? So we can, everyone knows what that means now, right? Great. OK, cool. OK, so I don't know why there's a lot of instructions about how this works. So the spec writes out exactly how you should consider each of these things, et cetera, et cetera. Wow, it keeps going. OK. Where is the? OK. All right. So then the other node sends back another message, the accept channel message. And part of this is their pubkey, right? So it should be, no, it's still long. No, there's still a lot of stuff. But they also have a funding pubkey. So they're gonna also send back a funding pubkey. Pubkey, which is also known as pubkey2, right? 

     funding_pubkey (pubkey2)
 
## exchange signatures
Okay. So now both parties, at the end of these two message exchanges, both parties are going to know what pubkey1 and pubkey2 are, right? Because node1 sent pubkey1 to their friend node2, and node2 responded back with pubkey2, right? So at this point, everyone has everything they need to build. Everyone has everything they need to fill in all the blanks in this one, right? If this is a blank here, and this is a blank here. That make sense? These are blanks. Now it's data. So we can make a locking script for our Bitcoin, and we can send our Bitcoin to this output, and we will have a channel. Everyone see how that works? 

          -> OP_2 <pubkey1> <pubkey2> OP_2_CHECKMULTISIG

So why do we have, let me go back up to the top of this page. Oh, we went too far. Why do we have all these other messages? We just sign everything we need for the address, right? 

I don't know, maybe I went way more too into detail. That's fine. I'll just keep talking, it's cool. Okay. Right, So now we have all the info we need to open a channel, right? So you can send bitcoins. Let's say we have an enormous amount of bitcoin. Let's say we have five bitcoin. And we're just going to send it to this address, right? So we can turn this into a bitcoin address. We can send some money to BTC address. 

     5 btc ==> btc address

And then it's going to take two signals. So OK, so right now, basically, the way it works is node one is going to take this BTC address. And they're the only one. They're going to send money to this address by themselves. So they're just going to lock up their money into this address. So what is that? So node one is going to make a little transaction, and they're going to send money to the Bitcoin address. And now in order to move their 5 bitcoin, they need a sign off from node 2. So node 2 needs to sign to move the 5 bitcoin. So what are some downsides to doing this? When the channel opens, Who has Bitcoin that they can spend in the channel? Only node one, right? Because node one sent money to that address, right? Node two knows the address, right? Node two could also just send money to that address, right? Right? I mean, let's be real, right? Everyone knows what the address is. What if we just all start sending money to the address, right, that seems fine. So then we'll have lots of UTXOs with money locked into it, right? We know what the address is, we can just send money there. Right, yeah, okay. This is a problem though, why is this a problem? Problem with this is that the protocol only makes it that you can, how do you say it? Okay, so once you send money to the transactions though, you need the other node's signature to spend it, to get it out, right? Or get it out. So if you Send money to this UTXO, so you send money to this Bitcoin address and you don't have the ability to, if you don't have the ability to spend it already and your peer disappears, you just lost five Bitcoin, right? Everyone following? So like, You send five bitcoin to an address, and someone else, some rando on the internet, some other node, gave you a pubkey that you locked up all your money to, and you can't actually get your money back without their signature, why would you do that? Would you do that? That doesn't seem like a good idea, right? OK. So we need a little more in the protocol, open channel protocol, right? We can't just stop after we've gotten the pub keys. We need a little more information before we send money to this address, right? So some downsides to this. 
## downsides to putting money in channel
Downsides, and The new protocol isn't going to fix all of these. Just spoiler alert. Right, so the downsides are that only one side can put money into a chain of open. And you really don't want to send money to the address, to the open address, until you know you can rescue it. You can spend it, right? Does that make sense? So you send money to an address, but you want to make sure you can spend from that address before you send money there, because that would be a really bad idea not to do. I've actually had some people that did that a few years ago for Lightning, and changed the protocol work to give them more ability to use any wallet. They wanted to open a Lightning channel, and they sent money to an address without getting the ability to spend it first. And then the other node went away and closed the channel, and it was lost forever. So yeah. OK, great. So there's some other messages. So what's going to happen is node one. So let's go back up to here. I'm going to go back. I'm going to copy. I know. OK, I'm going to copy this down here. We're just going to keep having the conversation going. We're going to, hey guys, welcome. We're talking to how Lightning works. OK. OK, so then node one, after they've gotten the accept channel, they're going to build the transaction. They're going to build a transaction that sends money to that address. Because now they can make that address. So they're going to build a transaction that sends money. And then they're going to send over the wire to their buddy. They're going to send over the wire. They're going to send them the TXID and the funding out point, basically, and the V out. We call this the funding out point, I think. I don't know. So that's going to tell node 2 where to look for money on chain that will be found in channel open. So they let node 2 know. So they're going to build. So one side builds the transaction, and then they send to node 2 the information about that. So can I? Yeah, check this out. All it has in it. Oh, we also send a signature. That's fancy. OK. So we send the TXID, and we send the output. That's literally all that's in this message, right? Well, we're sending a TXID. 

     txid, vout (funding outpoint)

We're sending an output number. So these two pieces of information uniquely identify where you will be able to expect to see our Bitcoin on chain. Notice we haven't sent it yet. We're doing this all, we haven't sent it, this is where we're planning on sending it, right? So this is some pre-planning on our part in node one. And then we also send a signature that I don't want to explain right now. We send a signature, And let's just say that the signature lets node 2 rescue their money if this transaction ends up on chain, if that makes sense. So this is like, OK, I'm planning to send the money to this address. When I send the money to this address, you can use this signature from me, along with your own signature, to rescue the money, so to speak. So this is the node two now, if one and two signature. Let's node two get money back, right, Basically. So this lets node two get their money back if something goes wrong with the funding output, right? If I disappear, if I send all my money to it and then disappear forever, node two in theory could get, they haven't put any money in but they could get their non-money out anyways. But yeah, we do that. So node 2 gets it, and then what does node 2 send back? Node 2 is basically going to send back another message that's going to include their signature, right, basically, so that node one can then get their money out. And once node one has a signature from node two, they're going to go ahead and send the transaction, right? You're going to wait until you have the other party's permission to get your money out of that address before you send anything to that address. So you have a get out of jail card just in case the peer goes away. This is called the fun trivia fact. This is called the signature. This signature is for something called a commitment transaction. We're not going to cover that today, this is not a lightning class. But it might look like it. Okay, great. Okay, So literally the next message that they send back, this one here, it was great. I didn't even spend a lot of time so those are the best. They send back a funding sign message and inside of it, what's inside of it is literally just a signature. You guys see this? It's a message called funding sign and all that's in it is signature. So that's it. That's the conversation. And then I don't know what the last thing is. Yeah, that's basically it. These things basically, this ends here. 

Then you send the transaction and then they're like, wait, So then both sides wait for the funding, for the channel to open, which means we're waiting for the transaction that has the script that locks all the money up. But all the money is only known as one's money. So we're waiting for the output that has all of node's one's money in it to get mined into a block. And then you get buried to a certain depth, and then at that point we go, okay, channel's open! 

## channel ready lock transaction and broadcast to blockchain

And we send a message, the message that we send when that happens is called channel ready. 

     channel_ready

And we both send channel ready, so when node one sees it, get mine, it'll send a channel ready, well like mine to a certain depth, I think six blocks, it'll send it, and then when this one sees it, or no, we can negotiate how many blocks, and then this guy will send a channel ready, So this will happen sometime later, right? That's not really that interesting. Okay. Do I have any questions so far? Great, okay. So we have two people who wanna talk to each other about opening, you know, have a conversation about opening a channel, they have to exchange some pub keys, and then they have to exchange some signatures. And then once they get their signatures, one person who's built the transaction sends the transaction out to the blockchain, and as soon as it gets mined that channels considered like open and existing, right? 


## dealing with liquidity

Okay, so what were some downsides that we said about this? Does anyone remember what the downsides were? Drawbacks All the money is out on the other one Yeah All the money is on one side. Why is that a problem? Problem. Maybe like downside. Why is that not, I mean, self-optimal? Because there's no liquidity. There's no liquidity. So you can receive payments, but you can't sign payments, right? So it makes everything. So it makes every channel that opens in Bitcoin and lightning gun can only send one way every time a new channel opens You can only send one way so if you wanted to be able to send money in the opposite direction you would need to either make a payment or convince someone else to open a channel with you, towards you, right? So, and that costs more money, because every time you want to open a channel now, we have to make an on-chain transaction, and that'll have a literal world cost, right? Okay, so. You can also push to your mom's. Yes, but then, yes, you can push it, but why are you pushing the amount? Either for cancer or general. But what if you don't know the other node you're opening it with, right? What if you want to open a channel because it's good for your node to be connected in a graph in that way, but you don't know that guy, right? You're not supposed to know who runs the nodes, in theory, right? It's supposed to be, handily, be like a semi-anonymous set of people with money in the channel, right? Or money. So, okay, so it's like, okay, what if, you know, some very brilliant people in lightning got together and decided that they would make a new protocol that would, so what are the goals of the new protocol? I'm just trying to think of at least a couple more of his advises which will motivate what you're about to say, right? There's a couple more disadvantages to this, right? First of all, the fact that the channel's not balanced, because a lot of Lightning is based around the idea that there's a punishment risk, which is based around there being something to lose, So an unbalanced channel is a kind of a shitty thing. Yes. The second thing is, which is very relevant to what you're about to say, is if you pay into a mining channel, let's say one UTXO, somebody knows it's yours. They know who owns the funds in the channel at that point. The privacy is quite poor, at least when you start with a single-funded channel. Yep. Also, there's multiple funding inputs, then there's no common input on the channel. Only the peer input, the whole kind, the non-common. Common ownership risk, right, because only one person opened it, right? So everyone, all those funds in that channel open belong to the same party. And it's one of the two in there. And yeah. There's another one too, which is that it's hard, but it's also hard for new nodes to get in that liquidity. 

## receiving payments without liquidity

Which just means, so what this means in the real world, I mean like practically, is that you can't receive payments. Receive payments over Lightning is hard. So if you wanted to like open a shop and get people to buy cookies from you, it would be very difficult to get people to accept payments over Lightning because you need other people to open channels that you get and receive money, right? But then money to make money. Yeah, but then you have to spend the same amount that you receive, but you have to pre-spend it. That seems... Yeah, the one to one ratio of that, exactly. Yeah, yeah. Which is not very profitable. Yeah, I don't know what economic model that is. That's definitely not capitalism. All right, so we're gonna make a new protocol. One of the goals, well there's two goals, sort of.

## getting inbound liquidity with a protocol that receives UTXOs from two parties

 I mean the real motivating factor is that we wanna make it easier to get inbound, really, to get inbound. So this is like kind of one of the big goals. But in order to do that we said, okay, What if we let everyone, what do you call it, what if we let both sides, what if we let both sides construct a channel? What if we built the channel together? I mean, built the transaction together. So we gave, basically, what if we made a protocol? Let's make a protocol where everyone can put money into the channel, money into the channel at open, right? And so what that means, so we want to be able to build a transaction that has UTXOs from two parties. So people of two parties can make one transaction with UTXOs from both people. Right? Does that make sense, everyone? So remember how a transaction is literally a list of inputs and then a list of outputs, right? So what if we had a way that the two people could talk and they would say, OK, I'm going to put input from node one. And then we could have an input from node 2, right? And then we could have, basically in our outputs, we have the channel funding, right? Channel funding output, which is the 2 of 2 multisig that we talked about, right? And then we can have the change output for node 1, and then a change output for node 2. Outputs, outputs. Right? Does that make sense? So OK, so what if we put it together, make a transaction that looks like this? So now two different people have inputs in the transaction. And there's a bunch of different places that the money is going. Because we've got this weird funding output. This is like shared funds that both parties own, right? It's kind of hard to tell. If I put in, I don't know, one bitcoin, and they put in, I don't know, I need bigger numbers, like 10 bitcoin, and this person puts in five bitcoin, right? And then let's say that into the funding output, node 1 wanted to put 3 bitcoin into this, right? So node 1's going to put 3 bitcoin in, and node 2 is going to put in, let's say they're going to put in 2 bitcoin, right? So then node 1 is going to have how much change? Node 1 put in 10, and they put 3, so they're going to get 7 bitcoin back. Oh, OK, wait, let me make this a little bit better so again let's say they put six in so how many would they get four back right And then this one would get like how many, three back? It's kind of hard to tell, I think, maybe I'm making this up, but I think it would be difficult to tell whose money went where, right? Because it's plausible, because this is going to be, so this is all. It's better. Well, we've occasionally got multiple possible solutions, but this, you just literally can't find a solution. Is the reason why you have the change out of this so that people analyzing the transaction can't tell which money goes into the channel? You don't have to. You could, but it's optional. OK, because it seems like you could just have the inputs be the size of the channel, and then the change doesn't even participate in this kind of thing. Yeah, you could have that. It depends. There's options. Maybe you don't want to put all your 10 Bitcoin in a channel with node 2. Maybe you just don't like them that much. Maybe it's not a good place for you to put your stuff. I don't know. It could also be that just node 1 puts all of its money into the channel and only node 2 gets a change. But then you don't know who's changing it. Exactly. Yeah. So anyway, so there's some cool stuff about this, right? And the reason that you get that is because this is like a joint account you've created. And so it becomes harder to tell where the Bitcoin went because some of it went into a joint account and you don't know who has how much at the start, right? So, okay, so there's a couple of cool things you can notice here, right? One is both nodes will have money in the channel. It's not an even amount if you decide how much money they want to put in, but it makes it possible that both can both send and receive immediately through this channel. How much is different, but it makes it such that you get set or receive payments all at once. It's only one transaction, and you get a little bit of savings in the fact that it's only one. You get some savings by having one channel deployed. So in order to make this happen, what are we going to have to change? So this is our goal, right? So when you're designing a protocol, the first thing that you figure out is what you want to be able to, what information do we need to share, what information do we need to have a conversation about so that we can achieve our goal. Our goal is to build a transaction together, right? So this is what we want, we want to be able to have a transaction. So both sides are gonna need, more or less, to know all the information. That's not strictly true, but we like doing things balanced for reasons and decentralized protocols. So we could send all the information to one node, right? We could have just one node send all of their input information to the other node, have them like blindly construct, have them construct a transaction and then just send the, which transaction I need back to the other node, right? But we don't want to do that. We want both sides to be able to build a transaction. Reasons? Not that I'm thinking about it, I don't know why I did that, but we did. Okay, so what are we going to do? We need to send information about the transaction over the wire now, back and forth, right? Back and forth, over the wire. Right, okay, so we needed a protocol for that. 

##  construction of interactive transaction protocol
We needed a new protocol. Protocol, one way to think of protocol is just like canned conversation, right? Like what am I allowed to say back and forth? Kind of like writing a script in a play for two actors that are very dry robots. Yeah, okay, so we need a protocol. And so we came up with a bit like an interactive transaction construction protocol. The goal is that, so we're reusing this for splicing. So this is for, we're going to reuse the same protocol for splicing, because splicing does the same work of making a new transaction with two parties. So the same work that's happening, it just happens in a different, there's a different setup and a different ending, but the middle part of when you're building the transaction is the same. And could it be used for non-library stuff? Sure, actually the DLC people, Yeah. The DLC people, Carmen is not here anymore, who's working on the protocol. They took the protocol that we wrote, changed it, because we wrote it in a way, we wrote it in a way that it's quite flexible in terms of, it lets you, how much do I want to talk about this? Alright, I'll say it. It makes it such that you can, the way that we constructed the transaction makes it such that you can build a transaction with parties that aren't just the two that are having the conversation? So there's some plausible deniability about who the inputs you're sending to your peer belong to. Whereas if you do it in a batch transaction way, you can't lose that capability. Whether or not this is something we should preserve and lightening is maybe a question, but you can do cool stuff with it. It lets you basically do, it basically lets you build, open start multiple channel opens at the same time and build one transaction that opens multiple four, five, six channels in the same transaction. So you basically get like a decentralized multi-party transaction that anyone who runs the Lightning node can kick off any time they want, right? Okay, anyways, all right, that's what I was gonna say. So you're trying to preserve the idea that not everyone needs to know about all the other channels of minus two training, so you might not know about other ones that have. No, yeah, yeah, yeah, It just looks like outputs for the other nodes. So it doesn't matter. And you can do this. It's a fun fact. 

## core lightning
You can do this on  Core Lightning already. It's already implemented. It exists. Everything I'm talking about today exists on Core Lightning. And you can do it. Maybe I should try doing it open fun channel, open fun channel. Oh, you can do that. That would be fun. OK. How much time do I have? All right, I'm really over time, so I'm gonna talk for another five minutes. Okay, so let's just go for giggles, maybe browse through what's kind of changed about it. It's in pull requests, it's a proposal. Core Lightning is implemented, that's the project I work on [interactive_tx: Add dual funding flow](https://github.com/lightning/bolts/pull/851). Eclair, which is a French team that does Lightning, has also implemented it, so we're in the sort of final stages, when I'm not working on conferences, of getting it running, of getting it basically, what do you call it, ratified so it would be considered part of the spec. But, that's gonna be two. This one. So this is a pull request. It's a proposal. Wow, that's almost 325 comments. I didn't find out the... You know, we've been working on this for a while. Great, okay, so let's just go look at the file changes. So, yeah, okay. I made a whole video where I explain it too, so if you want to watch me watch through another video where I explain how it works, there's that exists in the pull request. Where do I find, Is there a way to like, OK. Maybe I should pull out the, I don't have it on this computer. OK. Commits. File changes. This one. Oh, look. This is most of it. Doot, doot, doot, doot, doot, doot, doot. I'm sorry. I'm not. All right. Let me make it small for a second so I can see what's going on. Oh, large shift. OK. I feel like there's a way to just look at the branch. Let's just go do that. It's a lot easier. This branch, yeah, let's just go to the branch and look at it there. Let's go to gadget branch viewer. OK, so basically in here, we've changed it. We've added stuff. So where? OK, so it used to be. So this is, we've now changed channel establishment from the last time. We've now given it this nice little name v1, right? So that was version 1. And we've added a whole new thing of v2. So now we still have an open message, an accept message. Then we have this whole section of new stuff called the interactive transaction construction. That's like quite the mouthful. Okay. And then you kind of have some more stuff where you like finish it off. 

## RBF (replace by fee)

And then we also have this cool ability to do RBF now. So if you attempt to open a channel and then you wanna renegotiate it, we give you a protocol to be able to attempt to RBF the trick open if you don't have a correct name. With the collaboration of both funders. Yeah, yeah, yeah, yeah. There's no guarantee that this will work. Yeah, but it is. Yeah. But it's there, yeah, which is kind of cool. Great. OK. So I guess we can walk through. Wait, maybe there's, do I have, oh, I have diagrams. Check it out. OK, cool. Cool. So this is kind of how we were walking through how it works here with these little arrows back and forth. We have some diagrams in the specs that also do this. So node one is gonna send a message to node two. It's quite, there's a lot here. All right, you'll notice this is a lot shadier than the first version. There's a lot more information we have to send back and forth. Great. So. Can we make it a bit bigger? Yes, of course. Yeah. Oh. I regret that. What did I do? I'm sorry. I'm sorry. I'm sorry. I'm sorry. I'm sorry. I'm sorry. I'm sorry. I'm sorry. Great. Is that better? Can you guys see that okay? Great. Okay. So we still have like, node one is going to send a message, it's going to pick, so before all this there's a process of like picking a node that you want to open a channel with, right? So that's like a whole separate thing. You have to decide who you want to open a channel with, right? And liquidity ads is supposed to help with some of this. Like, who am I opening a channel with question. It helps answer the question, who can I open a channel with and expect them to put money in? Whatever, but hand-wave over that. So that's the coordination of how you coordinate that someone's going to put money in the channel with you as liquidity. Yeah, that's a whole other proposal, also included in Core Lightning, which is fun. OK, cool. Anyways, OK. So first of all, it's going to be like, OK, you. I'm going to open a channel with you. I'm going to send you an open channel message. Like, yo, I'm going to open a channel that's going to have a whole bunch of information in it about my pub key and all that other stuff we already saw. And then the other side is going to be like, OK, yeah, I will. This seems reasonable. I will open a channel with you. And so they'll say, OK, yes, I accept your proposal to open a channel, right?

## transaction collaboration communication i/o for transactions

 Then we get into a section that I call transaction collaboration, which is we start sending each other the inputs and outputs that, oh gosh, I really should put this up. So then we start doing this thing, here. Then we start sending each other a bunch of messages where we communicate, hey, this is an input that I want to add to a channel. Here's another input, here's an output. And so you just send each other back and forth all the inputs and outputs that you expect on this transaction, right? So one by one, each of you takes a turn. If you don't have anything to add, you just say no, pass. It's kind of like, you know, in card games, You're going around and you're like, OK, no, no, I have nothing this time. Pass. And so the other person plays another card. And then you say, no, no, I have nothing this time. So you say T is complete. Like, I don't have anything. They're like, OK, well, here's another input. And they're like, no, I don't have anything. Like, OK, well, here's an output. And then as soon as you get two people in the card round, basically, to say both say pass, then it ends. So you're kind of like dealing cards back and forth between each other, going around back and forth. And then at the end, after both say pass two in a row, you're like, okay, let's look at all the cards that people put on the table, right? And we're both gonna have the same set of inputs and outputs, and we're gonna take all this information that we've sent each other, and we're going to build a transaction with basically the set of cards that everyone's kind of put in the middle. Does that make sense? And the cards are sort of your inputs and outputs, right? So you sort of- Each input gets registered separately? Mm-hmm, non-batched. Yeah. So that you can get inputs from a third party. And so you're gonna be talking to someone else about this so as you get inputs from a third party you can send them to another one so you get kind of a ladder effect but then it looks like it's from And there's no ownership proof for those inputs? No, it's very basic. So it's a little greivable, right? This is a very basic, let's get the protocol working. Yeah, but if you want third party inputs, then ownership groups are a lot more difficult. Mm-hmm. But still pretty easy. Mm-hmm. Yeah. So it's possible that someone could send you complete junk and you build a transaction that they can't send you valid signatures for, in that case, well you just lost some time. You haven't really lost any money. And as long as you don't actually reserve any of those inputs until they get spent, it just doesn't. The attacker might at that point learn your inputs. Right, so this is an interesting aspect of it being a lightning open, and that's that all lightning opens become public information at some point, right? They're gonna know your inputs. Yeah, it's a little bit of information, Yeah. So like, each one has a similar issue, right? Yes. That the sender can query the new pixels of the merchant. It's a common problem with interactive transaction instruction things, yeah. And so each one solves it by signing a single user transaction with that input already that the merchant could broadcast. Yeah, so we have a proposal of how we, proposal for not that, but anyways, yeah, there's proposals on how to fix it, really, if you haven't. But currently there's just this agreement, yeah. 


##  relationship between UTXOs

Yeah, so there's a possibility that you link UTXOs for each other, that's true. Yeah. But there's a little bit of a thought in Lightning that your UTXOs aren't as important in Lightning as they are in, I mean they are important in terms of how much money you have the ability to spend, but they don't represent payments. 
They represent the ability to make batches of payments. So there's less of a relationship between your UTXOs and the amount of payments that represents, if that makes sense. You're assuming, you're talking about UTXOs that actually do end up in the channel, because it's good. That's true. But I don't mean, you know. That's true. We will get it. Yeah. We will get it. Yes. Yes, there are some definite downsides to this. Even the briefing isn't that bad because there could be a third party input that you included. Yes. So there's no way of, there's plausible deniability that it's not your UTXO. Yeah. Yeah. Yeah, yeah, yeah. That's why it's not batched, is that we preserve the possible deniability that they're not your UTXOs. They could be someone else's. Yeah. Okay. Anyway, so this is like, the spec just kind of has some like, you know, what if this happens? What if that happens? Yeah, okay. And then this defines how to add it, what information you need to send about an input, or what information you need to send about an output. And we also have the ability to remove inputs and outputs, which is pretty fancy. So you could add stuff and then remove it later. So if you had a third party that was in the new notation and then dropped out, you could remove them. I don't think we actually used this in our thing. We just failed it. I feel that's fine. OK. Cool. OK, so that's the back and forth stuff. So this is the biggest changes. OK, I think I'm way over time. I'm going to stop talking now. But so this is basically the big change between v1 and v2. 

##  construct exchange and spend and exchange signatures to broadcast

And so then now you also need to send, you need to send also at the end. So after you constructed the transaction, so you construct the transaction, right, together. And then you exchange signatures that let you spend from that transaction, spend from that transaction, right? So this means that, it's the same problem as before, you don't want to publish the transaction before you signature it, so you get the signatures to do it. And then the last thing you do is you exchange signatures to broadcast the, you spend the funding transaction, basically, so there's kind of like, a couple more steps here. It's a lot more complicated than the original one. There's a lot more messages and talking that has to happen. But yeah, the setup is a little more whatever, but there's some cool properties that you get from that. We'll even keep talking. Okay, great. If you want to know more about the proposal, the whole thing is up on the internet.



At this PR thing, I don't know where it was, but if you go back, it was here earlier. It was at 851, yeah, so [PR851](https://github.com/lightning/bolts/pull/851), I'm like able to go, if you'd like to chime in, you know, 325 is not the record yet, We could make it a little bit. Yeah. Rookie numbers, we have not hit four digits yet. Yeah. Great. Anyways, cool. And then if you want to learn more about how to make this work on correlating, I feel like the fun one is multi-fund channel with liquidity APIs, but I need to make a tutorial on how that works because that's fun. But I didn't think this. Anyways, look up multi-fund channel. You can go into docs and look. Yeah, we'll find the fund. OK. Yeah. Oh, let me find the multi-fund channel. It's not a fund. It's a fund. It's a fund. It's a fund. It's a fund. It is. Yeah. If you stop here, it's like multi-fund. It's a general fund. Yeah. Command for establishing multiple Lightning channels. And if you make it such that you do the request amount, basically, so there's a few little parameters in here you can add to each of them to buy liquidity ads. That'll basically, the liquidity ad is how you do the coordination to convince your peer to put money in the channel. And the way you convince them is you bribe them, you give them money, you're like, hey, I would like you to put money in the channel with me, and I'll pay you for it. The liquidity ad is a coordination mechanism for doing that, and So you get multi-fund channel with a bunch of channels that you buy liquidity from at the same time. And so that is how you would get a decentralized, self-coordinated fund join. OK, great. I'm way over time. Thank you everyone.
